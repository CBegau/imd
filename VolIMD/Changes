Aenderungen gegenueber dem Original-VolIMD:

ImgExaminerViewer.C und ImgFullViewer.C

   mehrere Variablen bool in boolvar umbenannt

render.C

   in load_and_classify_next_volume(char *filename):

      offenes File wieder geschlossen:

      close(volume_fd); /* FG - we cannot leave all those files open... */

   in new_classification():

      classification file bei File-Serie nicht schreiben und wieder lesen:
  
      /* store the classified volume */
      /* FG - do not store, if there are two dots in current_filename */
      if (strstr( strstr(current_filename,".") + 1, "." )==NULL) {
         ....
      }

      /* load new classified volume */
      /* FG - do reload, if there are two dots in current_filename */
      if (strstr( strstr(current_filename,".") + 1, "." )==NULL) {
         load_classified_volume(current_filename);
      }

menu.C: 

   Deklaration erganzt (int):

   extern int endianByteSwap; /* FG - this is an int */

menu.inc:

   in static MenuButtonTyp SimulationMenu[]:

      drei Eintraege auskommentiert:

      // FG - the following three are not needed for IMD
      //  {"change server name", "server name", M_SIM_CHANGE_NAME, M_PUSH_BUTTON, SimulationCB, 4 },	
      //  {"port on this machine", "toggleServer", M_SIM_PORT_MACHINE, M_TOGGLE_BUTTON, SimulationCB, 5 },	
      //  {"endian byte swap", "toggleServer", M_SIM_BYTE_SWAP, M_TOGGLE_BUTTON, SimulationCB, 6 },	

client.c

   in receive_distribution():  

      Test-Float lesen und endianByteSwap anpassen:

      /* FG - read test float, and check if endian swap is needed */
      ReadFull(socket_id, (void *) &f, sizeof(float));
      endianByteSwap = (f==(float)1.0) ? 0 : 1;
      if (endianByteSwap) {
         printf("endianByteSwap: yes\n");
      } else {
         printf("endianByteSwap: no\n");
      }
