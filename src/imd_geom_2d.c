/******************************************************************************
*
* imd_geom_2d.c -- cell decomposition routines for the imd package 2d version
*
******************************************************************************/

/******************************************************************************
* $RCSfile$
* $Revision$
* $Date$
******************************************************************************/

#include "imd.h"

/* To determine the cell into which a given particle belongs, we
   have to transform the cartesian coordinates of the particle into
   the coordinate system that is spanned by the vectors of the box
   edges. This yields coordinates in the interval [0..1] that are
   multiplied bye global_cell_dim to get the cells index.

   Here we calculate the transformation matrix. */

void make_box( void )
{
  real det;

  /* Determinant */
  det = box_x.x * box_y.y - box_x.y * box_y.x;
  if ((0==myid) && (0==det)) error("Box Edges are parallel.");

  /* Inverse box */
  ibox_x.x =   box_y.y / det;
  ibox_x.y = - box_y.x / det;
  ibox_y.x = - box_x.y / det;
  ibox_y.y =   box_x.x / det;

  /* Transpose */
  tbox_x.x = ibox_x.x;
  tbox_x.y = ibox_y.x;
  tbox_y.x = ibox_x.y;
  tbox_y.y = ibox_y.y;
}


/* Calculate smallest possible cell (i.e. the height==cutoff) */

ivektor maximal_cell_dim( void )
{
  real hx, hy;
  ivektor max_cell_dim;

  hx = SPROD(box_x,box_x) - SPROD(box_x,box_y);
  hy = SPROD(box_y,box_y) - SPROD(box_x,box_y);
  max_cell_dim.x = (int) (1.0 / sqrt( r2_cut / hx ));
  max_cell_dim.y = (int) (1.0 / sqrt( r2_cut / hy ));
  return(max_cell_dim);
}


/* init_cells determines the size of the cells. The cells are
   generated by scaling of the box. The scaling is done such that the
   distance between two of the cell's faces (==height) equals the
   cutoff.  An integer number of cells must fit into the box. If the
   cell calculated by the scaling described above is to small, it is
   enlarged accordingly.

   There must be at least three cells in each direction.  */


void init_cells( void )

{
  int i, j, k;
  real hx, hy, tmp; 
  vektor cell_scale;
  ivektor next_cell_dim, cell_dim_old;
  ivektor cellmin_old, cellmax_old, cellc;
  cell *p, *cell_array_old; 

#ifdef NPT
  if (ensemble == ENS_NPT_ISO) {

#ifdef MPI
    if (0 == myid )
#endif
    printf("actual_shrink=%f limit_shrink=%f limit_growth=%f\n",
            actual_shrink.x, limit_shrink.x, limit_growth.x );
  }
  else if (ensemble == ENS_NPT_AXIAL) {

#ifdef MPI
    if (0 == myid ) {
#endif
      printf("actual_shrink.x=%f limit_shrink.x=%f limit_growth.x=%f\n",
              actual_shrink.x,   limit_shrink.x,   limit_growth.x );
      printf("actual_shrink.y=%f limit_shrink.y=%f limit_growth.y=%f\n",
              actual_shrink.y,   limit_shrink.y,   limit_growth.y );
#ifdef MPI
    };
#endif
  };
#endif

  /* Calculate smallest possible cell (i.e. the height==cutoff) */

  /* Height x */
  hx = SPROD(box_x,box_x) - SPROD(box_x,box_y);
  
  /* Height y */
  hy = SPROD(box_y,box_y) - SPROD(box_x,box_y);
  
  /* Scaling factors box/cell */
  
  cell_scale.x = sqrt( r2_cut / hx );
  cell_scale.y = sqrt( r2_cut / hy );
#ifdef NPT
  if ((ensemble == ENS_NPT_ISO) || (ensemble == ENS_NPT_AXIAL)) {
    /* the NEXT cell array for a GROWING system; 
       needed to determine when to recompute the cell division */
    next_cell_dim.x = (int) ( (1.0 + cell_size_tolerance) / cell_scale.x );
    next_cell_dim.y = (int) ( (1.0 + cell_size_tolerance) / cell_scale.y );
    cell_scale.x   /= (1.0 - cell_size_tolerance);
    cell_scale.y   /= (1.0 - cell_size_tolerance);
  };
#endif
  /* set up the CURRENT cell array dimensions */
  global_cell_dim.x = (int) ( 1.0 / cell_scale.x );
  global_cell_dim.y = (int) ( 1.0 / cell_scale.y );

#ifdef MPI
  if (0 == myid )
#endif
  printf("Minimal cell size: \n\t ( %f %f ) \n\t ( %f %f ) \n",
	 box_x.x * cell_scale.x, box_x.y * cell_scale.x, 
	 box_y.x * cell_scale.y, box_y.y * cell_scale.y); 

#ifdef MPI
  /* cpu_dim must be a divisor of global_cell_dim */
  if (0 != (global_cell_dim.x % cpu_dim.x))
     global_cell_dim.x = ((int)(global_cell_dim.x/cpu_dim.x))*cpu_dim.x;
  if (0 != (global_cell_dim.y % cpu_dim.y))
     global_cell_dim.y = ((int)(global_cell_dim.y/cpu_dim.y))*cpu_dim.y;
#ifdef NPT
  if ((ensemble == ENS_NPT_ISO) || (ensemble == ENS_NPT_AXIAL)) {
    /* cpu_dim must be a divisor of next_cell_dim */
    if (0 != (next_cell_dim.x % cpu_dim.x))
       next_cell_dim.x = ((int)(next_cell_dim.x/cpu_dim.x))*cpu_dim.x;
    if (0 != (next_cell_dim.y % cpu_dim.y))
       next_cell_dim.y = ((int)(next_cell_dim.y/cpu_dim.y))*cpu_dim.y;
  };
#endif
#endif
  
  /* Check if cell array is large enough */
#ifdef MPI
  if (0 == myid ) {
    if (global_cell_dim.x < cpu_dim.x) error("global_cell_dim.x < cpu_dim.x");
    if (global_cell_dim.y < cpu_dim.y) error("global_cell_dim.y < cpu_dim.y");
#endif
    if (global_cell_dim.x < 3)         error("global_cell_dim.x < 3");
    if (global_cell_dim.y < 3)         error("global_cell_dim.y < 3");
#ifdef MPI
  };
#endif

#ifdef NPT

  if ((ensemble == ENS_NPT_ISO) || (ensemble == ENS_NPT_AXIAL)) {
    /* if system grows, the next cell division should have more cells */
#ifdef MPI
    if (next_cell_dim.x == global_cell_dim.x) next_cell_dim.x += cpu_dim.x;
    if (next_cell_dim.y == global_cell_dim.y) next_cell_dim.y += cpu_dim.y;
#else
    if (next_cell_dim.x == global_cell_dim.x) next_cell_dim.x += 1;
    if (next_cell_dim.y == global_cell_dim.y) next_cell_dim.y += 1;
#endif
  };

  if (ensemble == ENS_NPT_ISO) {
    /* factor by which a cell can grow before a change of
       the cell division becomes worthwhile */
    limit_growth.x = cell_scale.x * next_cell_dim.x;
    tmp            = cell_scale.y * next_cell_dim.y;
    /* getting more cells in at least one direction is enough */
    limit_growth.x = MIN( limit_growth.x, tmp );
    /* factor by which a cell can safely shrink */
    limit_shrink.x = cell_scale.x * global_cell_dim.x;
    tmp            = cell_scale.y * global_cell_dim.y;
    limit_shrink.x = MAX( limit_shrink.x, tmp );
    limit_shrink.x = limit_shrink.x * (1.0 - cell_size_tolerance);
  };

  if (ensemble == ENS_NPT_AXIAL) {
    /* factors by which a cell can grow before a change of
       the cell division becomes worthwhile */
    limit_growth.x = cell_scale.x * next_cell_dim.x;
    limit_growth.y = cell_scale.y * next_cell_dim.y;
    /* factor by which a cell can safely shrink */
    limit_shrink.x = cell_scale.x*global_cell_dim.x*(1.0-cell_size_tolerance);
    limit_shrink.y = cell_scale.y*global_cell_dim.y*(1.0-cell_size_tolerance);
  };

#endif /* NPT */

  /* If an integer number of cells does not fit exactly into the box, the
     cells are enlarged accordingly */
  cell_scale.x = 1.0 / global_cell_dim.x;
  cell_scale.y = 1.0 / global_cell_dim.y;

#ifdef MPI
  if (0 == myid )
#endif
  printf("Actual cell size: \n\t ( %f %f ) \n\t ( %f %f ) \n",
	 box_x.x * cell_scale.x, box_x.y * cell_scale.x,
	 box_y.x * cell_scale.y, box_y.y * cell_scale.y);

#ifdef MPI
  if (0==myid)
#endif
  printf("Global cell array dimensions: %d %d\n",
          global_cell_dim.x,global_cell_dim.y);

  /* keep a copy of cell_dim & Co., so that we can redistribute the atoms */
  cell_dim_old = cell_dim;
  cellmin_old  = cellmin;
  cellmax_old  = cellmax;

#ifdef MPI
  /* this thest should be obsolete now */
  if (0 == myid ) {
     if ( 0 !=  global_cell_dim.x % cpu_dim.x ) 
        error("cpu_dim.x no divisor of global_cell_dim.x");
     if ( 0 !=  global_cell_dim.y % cpu_dim.y ) 
        error("cpu_dim.y no divisor of global_cell_dim.y");
  };

  cell_dim.x = global_cell_dim.x / cpu_dim.x + 2;  
  cell_dim.y = global_cell_dim.y / cpu_dim.y + 2;
  
  cellmin.x = 1;
  cellmin.y = 1;

  cellmax.x = cell_dim.x - 1;
  cellmax.y = cell_dim.y - 1;
  
  if (0==myid) 
    printf("Local cell array dimensions (incl buffer): %d %d\n",
	   cell_dim.x,cell_dim.y);
#else

  cell_dim.x = global_cell_dim.x;
  cell_dim.y = global_cell_dim.y;

  cellmin.x = 0;
  cellmin.y = 0;

  cellmax.x = cell_dim.x;
  cellmax.y = cell_dim.y;

  printf("Local cell array dimensions: %d %d\n",
	 cell_dim.x,cell_dim.y);
#endif

  /* get box transformation matrix */
  make_box();

  /* save old cell_array (if any), and allocate new one */
  cell_array_old = cell_array;
  cell_array = (cell *) malloc( cell_dim.x * cell_dim.y * sizeof(cell) );
#ifdef MPI
  if ( 0 == myid )
#endif
  if (NULL == cell_array) error("Can't allocate memory for cells");

  /* initialize cells */
  for (i=0; i < cell_dim.x; ++i)
    for (j=0; j < cell_dim.y; ++j) {
      p = PTR_2D_V(cell_array, i, j, cell_dim);
      p->n_max=0;
      alloc_cell(p, CSTEP);
  };

  /* on the first invocation we have to set up the MPI process topology */
#ifdef MPI
  if (cell_array_old == NULL) setup_mpi_topology();
#endif

  /* redistribute atoms */
  if (cell_array_old != NULL) {
    for (j=cellmin_old.x; j < cellmax_old.x; j++)
      for (k=cellmin_old.y; k < cellmax_old.y; k++) {
	p = PTR_2D_V(cell_array_old, j, k, cell_dim_old);
        for (i = p->n - 1; i >= 0; i--) {
#ifdef MPI
          cellc = local_cell_coord(p->ort X(i),p->ort Y(i));
          /* strangly, some atoms get into buffer cells; 
             we push them back into the real cells, 
             so that we don't lose them  */
          if (cellc.x == 0) cellc.x++;
          if (cellc.y == 0) cellc.y++;
          if (cellc.x == cellmax.x) cellc.x--;
          if (cellc.y == cellmax.y) cellc.y--;
#else
          cellc = cell_coord(p->ort X(i),p->ort Y(i));
#endif
          move_atom( cellc, p, i );
        };
        alloc_cell( p, 0 );  /* free old cell */
    };
    free(cell_array_old);
  };

#ifdef NPT

  if ((ensemble == ENS_NPT_ISO) || (ensemble == ENS_NPT_AXIAL)) {
    revise_cell_division = 0;
    cells_too_small      = 0;
    actual_shrink.x      = 1.0;
    actual_shrink.y      = 1.0;
  };

  if (ensemble==ENS_NPT_ISO) {

#ifdef MPI
    if (0 == myid )
#endif
    printf("actual_shrink=%f limit_shrink=%f limit_growth=%f\n",
            actual_shrink.x, limit_shrink.x, limit_growth.x );
  }
  else if (ensemble == ENS_NPT_AXIAL) {

#ifdef MPI
    if (0 == myid ) { 
#endif
      printf("actual_shrink.x=%f limit_shrink.x=%f limit_growth.x=%f\n",
              actual_shrink.x,   limit_shrink.x,   limit_growth.x );
      printf("actual_shrink.y=%f limit_shrink.y=%f limit_growth.y=%f\n",
              actual_shrink.y,   limit_shrink.y,   limit_growth.y );
#ifdef MPI
    }; 
#endif
  };

#endif /* NPT */

}


/*
*
* cell_coord gives the (integral) cell_coorinates of a position
*
*/

ivektor2d cell_coord(real x,real y)

{
  ivektor2d coord;
  vektor ort;

  /* Ugly */
  ort.x = x;
  ort.y = y;

  /* Map positions to boxes */
  coord.x = (int) TRUNC( global_cell_dim.x * SPROD(ort,tbox_x) );
  coord.y = (int) TRUNC( global_cell_dim.y * SPROD(ort,tbox_y) );

  /* Roundoff errors put atoms slightly out of the simulation cell */
  /* Great mess, needs more investigation */
  coord.x = coord.x <   0                ?                    0 : coord.x;
  coord.x = coord.x >= global_cell_dim.x ? global_cell_dim.x -1 : coord.x;
  coord.y = coord.y <   0                ?                    0 : coord.y;
  coord.y = coord.y >= global_cell_dim.y ? global_cell_dim.y -1 : coord.y;

  return(coord);
}


/* map vektor back into simulation box */

vektor back_into_box(vektor pos)
{
  vektor d;
  int i;

  i = FLOOR(SPROD(pos,tbox_x));
  d.x  = pos.x - i *  box_x.x;
  d.y  = pos.y - i *  box_x.y;

  i = FLOOR(SPROD(pos,tbox_y));
  d.x -= i *  box_y.x;
  d.y -= i *  box_y.y;

  return(d);

}


