	<HTML> <HEAD> <TITLE> EAM </TITLE>
<!-- Changed by: Jutta Hahn, 27-Oct-1998, 14-Sep-1999 -->
	</HEAD> <BODY BGCOLOR="#FFFFFF"> <H1><font color=blue>
Implementation of EAM</font></H1> 

	<ul><li><b>
EAM</b><p>
An <font color=blue>E</font>mbedded <font color=blue>A</font>tom 
<font color=blue>M</font>ethod <font color=blue>(EAM)</font> is 
implemented in IMD by Jutta Hahn. For this the EAM procedure for 
molybdenum given by Finnis/Sinclair has been chosen (M. W. Finnis 
and J. E. Sinclair  1984, <EM>Phil. Mag.</EM> A, <B>50</B>, 45). <P>
	<li><b>
Interaction potential</b><p>
The interaction between N particles is given by the sum of two potential terms <P>
U<sub>tot</sub> = <font color=red>U<sub>P</sub></font> + <font color=green>U<sub>N</sub></font><P>
with <font color=red>U<sub>P</sub></font> the conventional central pair potential summation and 
<font color=green>U<sub>N</sub></font> the N-body potential term.<P>
	<ul><li>
In detail, the total energy is <P> <PRE>
U<sub>tot</sub> = <font color=red>\sum<sub>i,j</sub><sup>N</sup> U<sub>ij</sub></font>    - <font color=green>A * \sum<sub>i</sub><sup>N</sup> f(\rho<sub>i</sub>)</font>                (1) <BR>
U<sub>tot</sub> = <font color=red>\sum<sub>i,j</sub><sup>N</sup> U<sub>ij</sub></font>    - <font color=green>A * \sum<sub>i</sub><sup>N</sup> \sqrt(\rho<sub>i</sub>)  </font>          (2) <BR>
U<sub>tot</sub> = <font color=red>\sum<sub>i,j</sub><sup>N</sup> U<sub>ij</sub></font>    - <font color=green>A * \sum<sub>i</sub><sup>N</sup> \sqrt(\sum<sub>j</sub><sup>N</sup> \phi<sub>ij</sub>) </font>   (3) <BR>
U<sub>tot</sub> = <font color=red>\sum<sub>i,j</sub><sup>N</sup> U(r<sub>ij</sub>)</font> - <font color=green>A * \sum<sub>i</sub><sup>N</sup> \sqrt(\sum<sub>j</sub><sup>N</sup> \phi(r<sub>ij</sub>))</font> (4) </PRE> <P>
with the distance r between two particle i and j and the EAM constant 
<font color=green>A</font>. In equation (1) the N-body potential term 
is written as the sum of a cohesive function <font color=green>f</font>. 
Typical to EAM is the square root function <font color=green>f(\rho<sub>i</sub>) 
= \sqrt(\rho<sub>i</sub>)</font> (eq. (2)). <font color=green>\rho</font> 
can be explained as a density function, which is written in equation (3) 
as the sum of a pair function <font color=green>\phi<sub>ij</sub></font>. 
In order to calculate <font color=red>U<sub>ij</sub></font> and 
<font color=green>\phi<sub>ij</sub></font> one uses pairwise distance 
depended functions, <font color=red>U(r<sub>ij</sub>)</font> and 
<font color=green>\phi(r<sub>ij</sub>)</font> (eq. (4)). <P>
	<li>
In case of molybdenum, vanadium, and others the expressions for 
<font color=red>U(r<sub>ij</sub>)</font> and <font color=green>\phi(r<sub>ij</sub>)</font>
are: <P>
<pre><font color=red>U(r<sub>ij</sub>)</font> = (r<sub>ij</sub> - <font color=red>c</font>) * (<font color=red>c<sub>0</sub></font> + <font color=red>c<sub>1</sub></font>*r<sub>ij</sub> + <font color=red>c<sub>2</sub></font>*r<sub>ij</sub><sup>2</sup>)               (5) </pre><P>
for all r<sub>ij</sub> lower or equal <font color=red>c</font> while 
for r<sub>ij</sub> > <font color=red>c</font> the potential U(r<sub>ij</sub>) is zero, and <P>
<pre><font color=green>\phi(r<sub>ij</sub>)</font> = (r<sub>ij</sub> - <font color=green>d</font>)<sup>2</sup>                                    (6)</pre><P>
for all r<sub>ij</sub> lower or equal <font color=green>d</font> while for r<sub>ij</sub> > <font color=green>d </font>
the potential \phi(r<sub>ij</sub>) is zero. <font color=red>c</font>, <font color=red>c<sub>0</sub></font>, <font color=red>c<sub>1</sub></font>, 
<font color=red>c<sub>2</sub></font>, <font color=green>d</font> are parameters typical for the element.  <P>
<img src=eam.gif><p>
	</ul>
Equations (4)-(6) are realized in IMD. The pair potential <font color=red>
U<sub>P</sub></font> is still applied by a potential table, while in case 
of the cohesive function <font color=green>U<sub>N</sub></font> the potential 
and its derivative (force) are analytically calculated.  <P>

The left formula of equation (4) can be solved like in case of 'classical' 
IMD. However, the main problem arises from the square root calculation of 
a sum of pairwise 'interactions' <font color=green>\sqrt(\sum \phi<sub>ij</sub>)</font>;  the right 
formula of equation (4). The following strategy is applied: <P>
	<UL>
	<LI>
Part 1: calculate the pair potential <font color=red>\sum U(r<sub>ij</sub>)</font>, 
its derivative and sumarize the cohesive function <font color=green>
\phi(r<sub>ij</sub>)</font>. Moreover, remember the eam neighbors and 
some more characteristics needed later.
	<LI>
Part 2: calculate <font color=green>\sqrt(\rho<sub>i</sub>)</font>, tot_pot_energy and the eam forces.
	</UL><p>
This strategy results in two loops over all particles i = 0 ... N. The first
loop counts the pair interaction and saves a neighbour list, while in the
second the loop the neighbour list is used for calculating the cohesive
energy. <P> 
	<li><b>
Parameters</b><p>
In order to use EAM a potential table for the pair interaction U(r<sub>ij</sub>) 
(eq. (5)) must be created. In addition to the 'classical' IMD, further parameters 
are used in the IMD input file *.imp: <P>

	<P><table bgcolor="#eeeeff"><tr align="left" valign="top"><th><td bgcolor="#ccccff">
<b>EAM  	<td bgcolor="#ccccff"> 
  <b>IMD variable <td bgcolor="#ccccff"> 
    <b>Description </th><tr align="left" valign="top"> <th><td>
A  	<td bgcolor="#ccccff"> 
  eam_A <td> 
    EAM constant; eq. (4) </th><tr align="left" valign="top"> <th><td>
d  	<td bgcolor="#ccccff"> 
  eam_r_cut <td> 
    EAM cohesive function cutoff radius; eq. (6) </th><tr align="left" valign="top"> <th><td>
&nbsp;  <td bgcolor="#ccccff"> 
  eam_r_0 <td> 
    EAM minimum distance </th><tr align="left" valign="top"> <th><td>
&nbsp;  <td bgcolor="#ccccff"> 
  eam_len <td> 
    maximum number of neighbors in the cohesive
    function calculation; technical value (memory) </th></table><br>
	<li><b>
The files</b><p>
The following files are modified (m) or created (c)<p>
	<table bgcolor="#eeeeff"><tr align="left" valign="top"><th><td bgcolor="#ccccff">
<b>File    <td bgcolor="#ccccff">     
  <b>Description  <td bgcolor="#ccccff"> 
    <b>(m/c) <tr align="left" valign="top"><th><td bgcolor="#ccccff"><font color=red>
Makefile</font><td>     
  for example: make imd_eam_risc_mik <td> 
    (m) </th><tr align="left" valign="top"><th><td bgcolor="#ccccff"> <font color=red>
prototypes.h</font><td>     
  new function: do_forces_eam_1(2)       	<td> 
    (m) </th><tr align="left" valign="top"><th><td bgcolor="#ccccff"> <font color=red>
globals.h</font><td>     
  global variables (eam_*)               	<td> 
    (m) </th><tr align="left" valign="top"><th><td bgcolor="#ccccff"> <font color=red>
config.h</font><td>     
  global constant (BINC)               	<td> 
    (m) </th><tr align="left" valign="top"><th><td bgcolor="#ccccff"> <font color=red>
imd_geom.c</font><td>     
  cell size increasing <td> 
   (m) </th><tr align="left" valign="top"><th> <td bgcolor="#ccccff"> <font color=red>
imd_mpi_util.c</font><td>     
  copy atoms to/from buffer <td> 
   (m) </th><tr align="left" valign="top"><th> <td bgcolor="#ccccff"> <font color=red>
imd_param.c</font><td>     
  define EAM variables for the parameter inputfile:                                   <br>
  eam_len (number of maximum allowed neighbors in cohesive function, 
  important to memory allocs), eam_A (EAM cohesive function constant), 
  eam_r_cut (cutoff radius for cohesive function) and eam_r_0 (minimum 
  distance for cohesive function).<td> 
    (m) </th><tr align="left" valign="top"> <th><td bgcolor="#ccccff"> <font color=red>
imd_main_(risc/mpi)_3d.c</font>   <td>     
  memory allocs, free memory and walk the cells;<br>    
  calls do_forces_eam_1(2).<td> 
    (m) </th><tr align="left" valign="top"> <th><td bgcolor="#ccccff"> <font color=red>
imd_forces_eam.c</font>  <td>     
  used instead of do_forces.c;           	<br> 
  main calculation routine;                    <br> 
  part 1: calculation of the pair potential and 
  its derivative (force) as well as performing 
  the pre-calculations of the cohesive function 
  (do_forces_eam_1)                      	<br>    
  part 2: resume calculation of the cohesive 
  function, the total energy and 
  evaluate the cohesive force function     
  (do_forces_eam_2)                      	<td> 
    (c) </th><tr align="left" valign="top"> <th><td bgcolor="#ccccff"> <font color=red>
*.imp</font>             <td>     
  parameter input file (example: Mo):  <PRE>
  <font color=green>eam_len</font>   50 	
  <font color=green>eam_A</font>     1.887117 
  <font color=green>eam_r_cut</font> 4.114825 
  <font color=green>eam_r_0</font>   1. 	</PRE><td> (c) 
  	</table> <P> 
Important: imd_forces_eam.c is a full copy of imd_forces.c and uses 
the classical pair potential plus additions concerning the EAM. Therefore, 
whenever anything is modified in imd_forces.c it should also maybe modified 
in imd_forces_eam.c <P> 
	<li><b>
Modified files in detail</b><p><table bgcolor="#eeeeff"> 
	<tr align="left" valign="top"> <th><td bgcolor="#ccccff"> <PRE> <font color=red>
<b>Makefile</font></PRE> </th><tr><th><td><PRE>
...
EAMSOURCES = imd_forces_eam.c
...
ifneq (,$(strip $(findstring eam,{MAKETARGET})))
CFLAGS  += -DEAM
SOURCES += ${EAMSOURCES}
...  </th><tr><th><td bgcolor="#ccccff"><PRE> <font color=red>
<b>prototypes.h</font></PRE> </B> </th><tr><th><td><PRE>
...
void do_forces_eam_1(cell *p, cell *q, vektor pbc);
void do_forces_eam_2(cell *p, cell *q, vektor pbc);
...  </th><tr><th><td bgcolor="#ccccff"><PRE> <font color=red>
<b>globals.h</font></PRE> </B> </th><tr><th><td><PRE>
...
EXTERN integer *eam_ij;        /* neighbor array */
EXTERN integer eam_len;        /* max neighbors */
EXTERN real *eam_rho;          /* cohesive function density */
EXTERN real *eam_dij_x;        /* distance in x direction */
EXTERN real *eam_dij_y;        /* distance in y direction */
EXTERN real *eam_dij_z;        /* distance in z direction */
EXTERN real eam_r_0;           /* EAM minimum distance */
EXTERN real eam_r_cut;         /* EAM cutoff radius */
EXTERN real eam_r2_cut;        /* EAM cutoff radius^2 */
EXTERN real eam_A;             /* EAM cohesive function constant A */
...  </th><tr><th><td bgcolor="#ccccff"><PRE> <font color=red>
<b>config.h</font></PRE> </B> </th><tr><th><td><PRE>
...
#ifdef TTBP 
#define BINC 5
#elif EAM
#define BINC 5
#else
#define BINC 4
#endif
...  </th><tr><th><td bgcolor="#ccccff"><PRE> <font color=red>
<b>imd_param.c</font></PRE> </B> </th><tr><th><td><PRE>
...
else if (strcasecmp(token,"eam_len")==0) {
  /* number of neighbours */
  getparam("eam_len",&eam_len,PARAM_INTEGER,1,1);
}
else if (strcasecmp(token,"eam_A")==0) {
  /* EAM constant for cohesive function */
  getparam("eam_A",&eam_A,PARAM_REAL,1,1);
}
else if (strcasecmp(token,"eam_r_cut")==0) {
  /* EAM: Cutoff of cohesive function */
  getparam("eam_r_cut",&eam_r_cut,PARAM_REAL,1,1);
  eam_r2_cut = eam_r_cut * eam_r_cut;
}
else if (strcasecmp(token,"eam_r_0")==0) {
  /* minimum distance of cohesive function */
  getparam("eam_r_0",&eam_r_0,PARAM_REAL,1,1);
}
...  </th><tr><th><td bgcolor="#ccccff"><PRE> <font color=red>
<b>imd_geom.c</font></PRE></B> </th><tr><th><td><PRE>
...
/* increase the size of the cell by 2 for EAM */
r2_cut2 = MAX( r2_cut, 2 * eam_r2_cut ); 
... </th><tr><th><td bgcolor="#ccccff"><PRE> <font color=red>
<b>imd_mpi_utils.c</font></PRE> </B> </th><tr><th><td><PRE>
...
<b>void copy_atoms(msgbuf *b, int k, int l, int m)</b>
...
#if defined(TTBP) || defined(EAM)
        b->data[ b->n++ ] = from->nummer[i];
#endif
...
<b>void process_buffer(msgbuf *b, int mode)</b>
...
#if defined(TTBP) || defined(EAM)
        if (mode == FORCE) {
      input->nummer[0] = b->data[j++];
        };
#endif
... </th><tr><th><td bgcolor="#ccccff"><PRE> <font color=red>
<b>imd_risc_main.c</font></PRE></B></th><tr><th><td><PRE>
...
<b>void main_loop_risc(void) </b>
...
/* memory allocation */
eam_rho   =  calloc(natoms,sizeof(real));
eam_ij    =  calloc(natoms*eam_len,sizeof(integer));
eam_dij_x =  calloc(natoms*eam_len,sizeof(real));
eam_dij_y =  calloc(natoms*eam_len,sizeof(real));
eam_dij_z =  calloc(natoms*eam_len,sizeof(real));
...
<A href=#CALC>calc_forces();</A>         
...
/* free memory space */
free(eam_rho);
free(eam_ij);
free(eam_dij_x);
free(eam_dij_y);
free(eam_dij_z);
...
<b>void <A name="CALC">calc_forces(void)</A> </b>
...
  memset(eam_rho,  0,(natoms+1)*        sizeof(real));
  memset(eam_ij,   0,(natoms+1)*eam_len*sizeof(real));
  memset(eam_dij_x,0,(natoms+1)*eam_len*sizeof(real));
  memset(eam_dij_y,0,(natoms+1)*eam_len*sizeof(real));
  memset(eam_dij_z,0,(natoms+1)*eam_len*sizeof(real));
...
/* Part 1: For half of the neighbours of this cell: pair int. */
for (l=0; l <= 1; ++l)
  for (m=-l; m <= 1; ++m)
    for (n=(l==0 ? -m  : -l ); n <= 1; ++n) { 
    ...
#ifdef EAM
    <a href=#EAM1>do_forces_eam_1(p,q,pbc);</A>
#else
    do_forces(p,q,pbc);
#endif /* EAM */
};
...
#ifdef EAM
/* Part 2: for all atoms (cohesive potential and force) */
for (i=0; i < cell_dim.x; ++i)
  for (j=0; j < cell_dim.y; ++j)
    for (k=0; k < cell_dim.z; ++k) {
    p = PTR_3D_V(cell_array,i,j,k,cell_dim);
    pbc.x = 0;
    pbc.y = 0;
    pbc.z = 0;
    q = p;
    <a href=#EAM2>do_forces_eam_2(p,q,pbc);</A>
};
#endif /* EAM */
...  </th><tr><th><td bgcolor="#ccccff"><PRE> <font color=red>
<b>imd_forces_eam.c</font></PRE></B> </th><tr><th><td><PRE>
...
<b>void <a name="EAM1">do_forces_eam_1(cell *ap, cell *aq, vektor apbc)</A></b>
...
/* Part 1: pair potential and force, save eam neighbors */
for (i = 0;i < p->n; ++i) {
  eam_pni = p->nummer[i];
  jstart = (p==q ? i+1 : 0);
  for (j = jstart; j < q->n; ++j) {
    d.x      = q->ort X(j)-tmp_d.x; ...
    radius2  = SPROD(d,d);
    eam_r_ij = sqrt(radius2);
    if (radius2 <= r2_cut) { /* 1. Cutoff: pair */
      pot_grad = 2*inv_r2_step*(dv+(chi-0.5)*d2v);
      pot_zwi  =  pot_k0+chi*dv+0.5*chi*(chi-1)*d2v;
      force.x  = d.x*pot_grad;...
      p->kraft X(i)  += force.x;...
      p->pot_eng[i]  += pot_zwi;...
      tot_pot_energy += 2*pot_zwi; /* Important! */
    }; /* if 1. Cutoff */
    if (radius2 <= eam_r2_cut) { /* 2. Cutoff: EAM) */
      eam_pnj    = q->nummer[j];
      eam_phi_ij = (eam_r_ij-eam_r_cut)*(eam_r_ij-eam_r_cut);
      eam_ij[eam_pni*eam_len] += 1;                   		/* &raquo; eam_2 */
      eam_k = eam_ij[eam_pni*eam_len];
      eam_ij[eam_pni*eam_len+eam_k] = q->nummer[j];  		/* &raquo; eam_2 */
      eam_dij_x[eam_pni*eam_len+eam_k] = d.x;...  		/* &raquo; eam_2 */
      eam_rho[eam_pni] += eam_phi_ij;                		/* &raquo; eam_2 */
      eam_ij[eam_pnj*eam_len] += 1;                     	/* &raquo; eam_2 */
      eam_k = eam_ij[eam_pnj*eam_len];
      eam_ij[eam_pnj*eam_len+eam_k] = p->nummer[i];  		/* &raquo; eam_2 */
      eam_dij_x[eam_pnj*eam_len+eam_k] = -d.x;... 		/* &raquo; eam_2 */
      eam_rho[eam_pnj] += eam_phi_ij;                		/* &raquo; eam_2 */
    } /* if 2. Cutoff */ 
}; /* j */ }; /* i */ 
...
<b>void <a name="EAM2">do_forces_eam_2(cell *p, cell *q, vektor pbc)</A></b> 
...
/* Part 2: calc of cohesive function and force, total energy */ 
eam_cf = 0.0;
for (i = 0;i < p->n; ++i) {
  eam_pni = p->nummer[i];
  eam_cf_i = sqrt(eam_rho[eam_pni]);             		/* &laquo; eam_1 */
  eam_cf += eam_cf_i;
  p->pot_eng[i] -= eam_A * eam_cf_i;
  eam_tmp_i  = 1./eam_cf_i;
  jstart = 1;
  jend = eam_ij[eam_pni*eam_len];                 		/* &laquo; eam_1 */
  for (j = jstart; j <= jend; ++j) {
    d.x = eam_dij_x[eam_pni*eam_len+j]; ...   			/* &laquo; eam_1 */
    radius2 = SPROD(d,d);
    eam_r_ik = sqrt(radius2);
    eam_k = eam_ij[eam_pni*eam_len+j];             		/* &laquo; eam_1 */
    eam_tmp_k = 1./sqrt(eam_rho[eam_k]);          		/* &laquo; eam_1 */
    eam_pot_grad  = - eam_A*(eam_tmp_i+eam_tmp_k)
                    *(eam_r_ik-eam_r_cut)/eam_r_ik;
    force.x = d.x * eam_pot_grad; ...
    p->kraft X(i) += force.x; ...
  }; /* for j */
}; /* for i */
tot_pot_energy  -= eam_A * eam_cf;
...  </th> </table><br><li><b>
Remarks</b><p><ul><li>
memory allocation for neighboring list is not done very effecient (especially in case of the parallel version)<li>
Atom type "0" is treated by EAM.<br>
Atom types "1,2,..." are treated by 'classical' pair interactions.<br>
(done because of the C/Mo project: carbon segregation in molybdenum; Rebecca Janisch).
	<li>
The parallel version is only active for non-AR case (no action=rectio).
	</ul><p><li><b>
See also</b><p>
The embedded code implemented by Erik Bitzek
	</ul> <P> <hr size = 0 width=100% noshade><small>
Written by Jutta Hahn (last update: Sep 15, 1999)</small><p> <A HREF="file:/common/share/itap/software/simulation/imd-html/imd.html">
Back to IMD User's Guide</A> <hr size = 0 width=100% noshade>
	</PRE></BODY> </HTML>
